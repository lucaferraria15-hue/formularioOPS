import { useState, useEffect, useMemo, useRef } from 'react'
import { motion, AnimatePresence } from 'framer-motion'

const sopSource = `SOP — Implementación Operativa Inicial (CANCHA 0)
SOP — Implementación Operativa Inicial (CANCHA 0)
Resumen ejecutivo

Entrá, diagnosticá y ordená. Capturá conocimiento clave (coach/closer/setter). Medí baseline y definí foco. Organizá equipos y herramientas. Activá canales de adquisición pertinentes y estandarizá la entrega. Instalá reuniones, tableros y mejora continua.

Objetivo y Resultado esperado

Objetivo: estabilizar y escalar el sistema comercial y de entrega con decisiones basadas en datos.

Resultado: SOPs por rol publicados, trackers activos, KPIs con baseline, reuniones instaladas, canales de adquisición operativos y plan de optimización continua.

Alcance (In/Out)

In: marketing de respuesta directa y contenido, seteo (DM/agenda), pre-call, llamadas de venta, cierre, onboarding, entrega de servicio, referidos/upsells/renovaciones/comunidad, reporting y gobierno operativo.

Out: legal/contable/fiscal, IT/infra, payroll, branding avanzado (Supuesto: fuera del alcance salvo coordinación puntual).

Roles y responsabilidades

CEO: fija visión, objetivos y restricciones. Aprueba prioridades. Provee accesos o autoriza instalación. Decide asignaciones de capital humano.

Coach/Entrega: aporta “descarga cerebral” del delivery, cuellos y estándares; co-diseña mejoras (gating, QA, referidos/upsell). Nota: en la mayoría de los casos el CEO es también el coach; puede existir un socio en ese rol.

Ops: orquesta el proceso, consolida datos, mantiene SOPs/trackers, lidera reuniones y reporting.

Setter: ejecuta guion de seteo, agenda manual, realiza pre-call por WhatsApp (con WhatsApp de la empresa), actualiza CRM del setter y Tracker.

Closer: ejecuta guion de cierre, registra y revisa llamadas (Fathom), reporta objeciones y mejoras a guiones y plantillas.

Contenido: opera calendario editorial y coordina con seteo/cierre. “Follow me” se evalúa según negocio (no obligatorio).

Herramientas

Slack (canales por área), ClickUp (docs/tareas/changelog), CRM del setter (no el corporativo), Tracker Empresa y Trackers por rol, Fathom (grabación), Skool (gating semanal), Stripe/Pasarela, Zapier/Make, Gmail/GSuite, Ads Manager (si aplica).
Accesos: si la empresa ya usa estas apps, entregar accesos; si no, instalarlas. Gmail corporativo: acceso obligatorio.

Proceso paso a paso
Día 1 — Aterrizaje y baseline

Paneo de equipo comercial. Roles, cargas, brechas, desempeño actual (observación).

Envío de entregables al Coach (SOPs y formularios).

Doc 1: https://docs.google.com/document/d/10hBkVPYKItYeP4PvLZAsQASJtPVM6RkT6qWywuU25_8/edit?usp=sharing

Doc 2: https://docs.google.com/document/d/1kV2AMyjk1Z2LbVfFO8r1Nm3tQJ5AzXeA3ijXqfBJXdw/edit?tab=t.0#heading=h.p8v6ne98bupl

Solicitar “descarga cerebral” por rol.

Closer: objeciones, guion de venta, ICP, uso de tracker, tareas. (Crear y enviar SOP Closer)

Setter: ICP, guion de seteo, CRM del setter, tracker y tareas. (Crear y enviar SOP Setter/CRM/Tracker/Guion)

Accesos críticos. Slack, ClickUp, CRM del setter, Trackers, Skool, Fathom, Stripe, Gmail corporativo (obligatorio), Zapier/Make, Ads Manager.

Cargar Tracker Empresa (mes anterior + mes actual).
LTB (Lead→Booked), Asistencia %, Cierre %, Cash Collected (nuevo dinero), Liquidez, Ticket promedio, Facturación, LTV (Life Time Value).

Definir ICP preliminar. CEO + Setter + Closer (quién compra hoy y por qué).

Reunión con CEO (hasta 2 horas, al final del día). Estado del negocio, metas, restricciones, equipo, decisiones inmediatas.

Día 2 — Adquisición y organización

Reunión con Coach. Diseñar/activar canales faltantes: referidos, upsells, renovaciones, comunidad paga.
Contenido “follow me” es opcional; evaluarlo según fit del negocio.

Ads a DM (si aplica). Escalar agenda +10–15% manteniendo bandas de Asistencia % y Cierre %.

Slack por área + ClickUp.
Canales: #comercial, #contenido, #entrega, #ops, #reportes, #cambios-sistema. Estructurar y publicar SOPs y documentos.

Día 3 — Delivery y protocolo

Análisis de entrega end-to-end. Onboarding, sesiones, soporte, QA, referidos/upsells/renovaciones, comunidad mensual.

Gating semanal en Skool. Checklist de avance + hitos que disparen referidos/upsell/renovación.

Protocolizar. Documentar “cómo se hace” desde contenido → venta → onboarding → renovación.

Semana 1 — Micro, coaching y datos

Seteo (ejecución). Adaptar guion al ICP; entrenar setter; pre-call por WhatsApp (cuenta de empresa); actualizar CRM del setter y Tracker.

Closing (profundización). Reunión de 2 horas con closer: procesos, subcomunicación, objeciones; revisar guion de ventas.

Reuniones:

Seters — Daily 15–20’ (bloqueo/avance/métrica).

Seters — Weekly 45–60’.

Closer — Revisiones: lunes, miércoles, viernes 14:30–15:00; sábado al terminar su jornada (repaso semanal y ajustes) con Fathom.

Recolección de datos (7 días). Medir impacto; nueva reunión con CEO para activar o ajustar canales (referidos/upsells/renovaciones/comunidad).

Operativa continua

Semanal: revisar KPIs; ajustes a guiones/plantillas; QA de llamadas; backlog de tests (contenido/ads si aplica).

Mensual: comparativa de meses; decisiones de presupuesto y headcount; actualización de SOPs y playbooks.

Checklists operativas (copy-paste)
Accesos iniciales

Slack, ClickUp, CRM del setter, Tracker Empresa, Trackers por rol, Skool, Fathom, Stripe, Gmail corporativo, Zapier/Make, Ads Manager.

Entregables Día 1

Enviar Docs al Coach (links arriba).

Pedir “descarga cerebral” a Closer y Setter.

Relevar equipo comercial e ICP preliminar.

Completar Tracker Empresa (mes anterior + actual).

Agendar reunión con CEO (hasta 2 h) al final del día.

Activación de adquisición (Día 2)

Referidos: trigger, script e incentivo.

Upsells: ofertas, timing y criterios.

Renovaciones: calendario y propuestas.

Comunidad paga: propuesta de valor y calendario.

Ads a DM (si aplica): plan de escalado y control de calidad.

Delivery y protocolo (Día 3)

Onboarding: email + acceso + checklist + primer hito.

Skool: gating semanal activo.

QA: criterios y métricas.

Triggers: referidos/upsell/renovación en semanas hito.

Reuniones Seters

Daily 15–20’: métricas de ayer, bloqueos, plan del día, asignaciones.

Weekly 45–60’: resumen, calidad (DMs/audios), procesos, acciones con owner y fecha.

Reuniones Closer

Lun/Mié/Vie 14:30–15:00 y sábado post-jornada: revisión de llamadas con Fathom, objeciones, ajustes de guion.

Gobierno de documentación

Publicar SOPs en ClickUp (vX.Y), changelog, owner por proceso.

Canal #cambios-sistema para avisos con fecha efectiva.

KPIs y fórmulas mínimas

LTB (Lead→Booked %) = Agendas hechas / Leads captados.

Asistencia % = Llamadas tomadas / Agendas confirmadas.

Cierre % = Ventas / Llamadas tomadas.

Cash Collected = Σ cobros efectivamente ingresados en el período.

Facturación = Σ ventas facturadas (nominal) del período.

Liquidez (meses) = Caja disponible / Gasto mensual promedio.

Ticket Promedio = Cash Collected / Nº de ventas (o Facturación / Nº de ventas, según política).

LTV (Life Time Value) = ARPU × Margen × Meses de retención.

EPS (Supuesto) = (Ingresos − Costos directos) / Nº de ventas.

Riesgos & Controles

Reunionitis. → Timebox estricto; dailies 15–20’, weeklies 45–60’; agenda publicada.

Ambigüedad de métricas. → Diccionario KPI único; fórmulas visibles en Tracker.

Escalar ads sin mantener calidad. → Solo +10–15% si Asistencia % y Cierre % dentro de banda.

Mensajería dispersa. → Usar WhatsApp de la empresa; plantillas aprobadas; registro en CRM del setter.

Datos dispersos. → Fuente de verdad: Tracker Empresa; cierre diario.

Gobernanza (canales, reuniones, reportes)

Canales: #comercial, #contenido, #entrega, #ops, #reportes, #cambios-sistema.

Reuniones: Seters (daily + weekly), Closer (Lun/Mié/Vie 14:30–15:00 y sábado post-jornada), CEO–Ops (dirección semanal 30–45’), cierre diario de métricas.

Reportes: dashboard semanal + comparativa mensual; changelog de SOPs en ClickUp.

Entregables y plantillas

Docs Coach: ver links en Día 1.

SOP Closer: (crear y publicar)

SOP Setter/CRM del setter/Tracker/Guion: (crear y publicar)

Tracker Empresa: (link interno)

Tracker de Entrega de Servicio: (crear y publicar)

Guion de Seteo (v1): (link)

Guion de Ventas (v1): (link)

Plantillas WhatsApp (pre-call/seguimiento): (link)`

type Block = { title: string; items: string[] }
type Step = { title: string; blocks: Block[] }

const sectionTitles = [
  'Resumen ejecutivo',
  'Objetivo y Resultado esperado',
  'Alcance (In/Out)',
  'Roles y responsabilidades',
  'Herramientas',
  'Proceso paso a paso',
  'Día 1',
  'Día 2',
  'Día 3',
  'Semana 1',
  'Operativa continua',
  'Checklists operativas (copy-paste)',
  'KPIs y fórmulas mínimas',
  'Riesgos & Controles',
  'Gobernanza (canales, reuniones, reportes)',
  'Entregables y plantillas'
]

function parseSection(lines: string[]): Block[] {
  const blocks: Block[] = []
  let i = 0
  while (i < lines.length) {
    const line = lines[i].trim()
    if (!line) { i++; continue }
    const next = lines[i + 1]?.trim()
    if (next === '' && lines[i + 2] && lines[i + 2].trim() !== '') {
      const title = line
      const items: string[] = []
      let j = i + 2
      while (j < lines.length && lines[j].trim() !== '') {
        items.push(lines[j].trim())
        j++
      }
      blocks.push({ title, items })
      i = j
    } else {
      const items: string[] = [line]
      let j = i + 1
      while (j < lines.length && lines[j].trim() !== '') {
        items.push(lines[j].trim())
        j++
      }
      blocks.push({ title: '', items })
      i = j
    }
  }
  return blocks
}

function parseSOP(src: string): Step[] {
  const lines = src.split('\n')
  const steps: Step[] = []
  let current: { title: string; lines: string[] } | null = null
  for (const raw of lines) {
    const line = raw.trim()
    const heading = sectionTitles.find(t => line === t || line.startsWith(t + ' '))
    if (heading) {
      if (current) {
        steps.push({ title: current.title, blocks: parseSection(current.lines) })
      }
      current = { title: raw.trim(), lines: [] }
    } else if (current) {
      current.lines.push(raw)
    }
  }
  if (current) steps.push({ title: current.title, blocks: parseSection(current.lines) })
  return steps
}

function cn(...c: string[]) {
  return c.filter(Boolean).join(' ')
}

function Accordion({ title, children, forceOpen }: { title: string; children: React.ReactNode; forceOpen: boolean }) {
  const [open, setOpen] = useState(forceOpen)
  useEffect(() => setOpen(forceOpen), [forceOpen])
  return (
    <div className="bg-[#12151A] border border-white/20 rounded-2xl mb-4 shadow">
      <button
        className="w-full text-left px-4 py-3 flex justify-between items-center focus:outline-none"
        onClick={() => setOpen(o => !o)}
      >
        <span>{title || 'Nota'}</span>
        <span>{open ? '−' : '+'}</span>
      </button>
      <AnimatePresence initial={false}>
        {open && (
          <motion.div
            key="content"
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: 'auto' }}
            exit={{ opacity: 0, height: 0 }}
            transition={{ duration: 0.15 }}
          >
            <div className="px-4 pb-4 text-[#A6ADBB] space-y-2">{children}</div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  )
}

function Checklist({ items }: { items: string[] }) {
  const [checked, setChecked] = useState<Record<number, boolean>>({})
  return (
    <ul className="space-y-2">
      {items.map((it, idx) => (
        <li key={idx} className="flex items-center gap-2">
          <input
            type="checkbox"
            checked={!!checked[idx]}
            onChange={() => setChecked(s => ({ ...s, [idx]: !s[idx] }))}
          />
          <span>{it}</span>
        </li>
      ))}
    </ul>
  )
}

function KpiBlock({ items }: { items: string[] }) {
  return (
    <ul className="list-disc pl-6 space-y-1 text-[#A6ADBB]">
      {items.map((it, i) => (
        <li key={i}>{it}</li>
      ))}
    </ul>
  )
}

function StepView({ step, expandAll }: { step: Step; expandAll: boolean }) {
  return (
    <motion.div
      key={step.title}
      initial={{ opacity: 0, x: 20 }}
      animate={{ opacity: 1, x: 0 }}
      exit={{ opacity: 0, x: -20 }}
      transition={{ duration: 0.15 }}
      className="space-y-4"
    >
      {step.blocks.map((b, i) => (
        <Accordion key={i} title={b.title} forceOpen={expandAll}>
          {step.title.includes('Checklist') ? (
            <Checklist items={b.items} />
          ) : step.title.includes('KPI') ? (
            <KpiBlock items={b.items} />
          ) : (
            <div className="space-y-2">
              {b.items.map((it, j) => (
                <p key={j}>{it}</p>
              ))}
            </div>
          )}
        </Accordion>
      ))}
    </motion.div>
  )
}

function StepRail({ steps, current, setCurrent, visited }: { steps: Step[]; current: number; setCurrent: (n: number) => void; visited: number }) {
  const refs = useRef<Array<HTMLButtonElement | null>>([])
  return (
    <aside className="w-56 bg-[#12151A] p-4 overflow-y-auto border-r border-white/20">
      <ul className="space-y-2">
        {steps.map((s, i) => (
          <li key={s.title}>
            <button
              ref={el => (refs.current[i] = el)}
              className={cn(
                'w-full text-left px-3 py-2 rounded-xl',
                i === current ? 'bg-white/10 text-white' : visited >= i ? 'text-[#F2F5F7]' : 'text-[#A6ADBB]'
              )}
              onClick={() => setCurrent(i)}
              onKeyDown={e => {
                if (e.key === 'ArrowDown') {
                  e.preventDefault()
                  refs.current[i + 1]?.focus()
                }
                if (e.key === 'ArrowUp') {
                  e.preventDefault()
                  refs.current[i - 1]?.focus()
                }
              }}
            >
              {s.title}
            </button>
          </li>
        ))}
      </ul>
    </aside>
  )
}

export default function SOPWizard() {
  const steps = useMemo(() => parseSOP(sopSource), [])
  const [current, setCurrent] = useState(0)
  const [visited, setVisited] = useState(0)
  const [expandAll, setExpandAll] = useState(false)

  useEffect(() => {
    setVisited(v => Math.max(v, current))
  }, [current])

  useEffect(() => {
    const handler = (e: KeyboardEvent) => {
      if (e.key === 'ArrowRight') setCurrent(c => Math.min(c + 1, steps.length - 1))
      if (e.key === 'ArrowLeft') setCurrent(c => Math.max(c - 1, 0))
      if (e.key === 'Home') setCurrent(0)
      if (e.key === 'End') setCurrent(steps.length - 1)
    }
    window.addEventListener('keydown', handler)
    return () => window.removeEventListener('keydown', handler)
  }, [steps.length])

  return (
    <div className="flex bg-[#0B0D10] text-[#F2F5F7] min-h-screen">
      <StepRail steps={steps} current={current} setCurrent={setCurrent} visited={visited} />
      <div className="flex-1 flex flex-col">
        <header className="flex justify-between items-center px-6 py-4 border-b border-white/20 bg-[#12151A]">
          <h1 className="text-lg font-semibold">{steps[current]?.title}</h1>
          <div className="space-x-2">
            <button
              className="px-3 py-1 rounded-lg bg-white/10"
              onClick={() => setExpandAll(e => !e)}
            >
              {expandAll ? 'Contraer todo' : 'Expandir todo'}
            </button>
            <button
              className="px-3 py-1 rounded-lg bg-white/10"
              onClick={() => setCurrent(c => Math.max(c - 1, 0))}
            >
              Anterior
            </button>
            <button
              className="px-3 py-1 rounded-lg bg-white/10"
              onClick={() => setCurrent(c => Math.min(c + 1, steps.length - 1))}
            >
              Siguiente
            </button>
          </div>
        </header>
        <main className="flex-1 p-6 overflow-y-auto">
          <AnimatePresence initial={false} mode="wait">
            <StepView key={current} step={steps[current]} expandAll={expandAll} />
          </AnimatePresence>
        </main>
      </div>
    </div>
  )
}

